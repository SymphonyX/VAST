<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>VAST: BestFirstSearchPlanner Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">VAST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">BestFirstSearchPlanner Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A state-space planning algorithm that uses a generalized best-first search.  
 <a href="class_best_first_search_planner.html#details">More...</a></p>

<p><a href="class_best_first_search_planner-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a00c06f79faf00907ec4906086c37776f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00c06f79faf00907ec4906086c37776f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_best_first_search_planner.html#a00c06f79faf00907ec4906086c37776f">init</a> (ref List&lt; <a class="el" href="class_planning_domain_base.html">PlanningDomainBase</a> &gt; newPlanningDomain, int maxNumNodesToExpand)</td></tr>
<tr class="memdesc:a00c06f79faf00907ec4906086c37776f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the planner to use the specified instance of the planning domain, and sets the search horizon limit. <br/></td></tr>
<tr class="memitem:ab9066bb695cb64fc787f747a4972d878"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9066bb695cb64fc787f747a4972d878"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_computePlan</b> (ref <a class="el" href="class_default_state.html">DefaultState</a> startState, ref <a class="el" href="class_default_state.html">DefaultState</a> idealGoalState, Dictionary&lt; <a class="el" href="class_default_state.html">DefaultState</a>, <a class="el" href="class_best_first_search_node.html">BestFirstSearchNode</a> &gt; stateMap, ref <a class="el" href="class_default_state.html">DefaultState</a> actualStateReached, float maxTime)</td></tr>
<tr class="memitem:a97dc3cad80e236bde9c7d9c44759c7ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97dc3cad80e236bde9c7d9c44759c7ba"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_computeOneStep</b> (ref <a class="el" href="class_default_state.html">DefaultState</a> startState, ref <a class="el" href="class_default_state.html">DefaultState</a> idealGoalState, Dictionary&lt; <a class="el" href="class_default_state.html">DefaultState</a>, <a class="el" href="class_best_first_search_node.html">BestFirstSearchNode</a> &gt; stateMap, ref <a class="el" href="class_default_state.html">DefaultState</a> actualStateReached, float maxTime)</td></tr>
<tr class="memitem:a777fb06939a33b3f3effb24b0dbda076"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a777fb06939a33b3f3effb24b0dbda076"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_best_first_search_planner.html#a777fb06939a33b3f3effb24b0dbda076">computePlan</a> (ref <a class="el" href="class_default_state.html">DefaultState</a> startState, ref <a class="el" href="class_default_state.html">DefaultState</a> goalState, ref Stack&lt; <a class="el" href="class_default_state.html">DefaultState</a> &gt; plan, float maxTime)</td></tr>
<tr class="memdesc:a777fb06939a33b3f3effb24b0dbda076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a plan as a sequence of states; returns true if the planner could reach the goal, or false if the plan is only partial and could not reach the goal within the specified horizon. <br/></td></tr>
<tr class="memitem:a0367a0321408a4d7c9796739650b2bee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0367a0321408a4d7c9796739650b2bee"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_best_first_search_planner.html#a0367a0321408a4d7c9796739650b2bee">computePlan</a> (ref <a class="el" href="class_default_state.html">DefaultState</a> startState, ref <a class="el" href="class_default_state.html">DefaultState</a> goalState, ref Stack&lt; <a class="el" href="class_default_action.html">DefaultAction</a> &gt; plan, float maxTime)</td></tr>
<tr class="memdesc:a0367a0321408a4d7c9796739650b2bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a plan as a sequence of actions; returns true if the planner could reach the goal, or false if the plan is only partial and could not reach the goal within the specified horizon. <br/></td></tr>
<tr class="memitem:af0e16fec4b04283bf4da46b5dcd6efe3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0e16fec4b04283bf4da46b5dcd6efe3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>VisualizeContainer</b> (ContainerType containerType, Color color, float radius)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a6cf3eaf1dece9104e57734fe46dc5c18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cf3eaf1dece9104e57734fe46dc5c18"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>_maxNumNodesToExpand</b></td></tr>
<tr class="memitem:a1ad8d9c366c660e9f9713118abdd9274"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ad8d9c366c660e9f9713118abdd9274"></a>
List&lt; <a class="el" href="class_planning_domain_base.html">PlanningDomainBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_planningDomain</b></td></tr>
<tr class="memitem:a257de3dcc541f70ef5be8bcb63ce8471"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a257de3dcc541f70ef5be8bcb63ce8471"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>oneStep</b> = false</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A state-space planning algorithm that uses a generalized best-first search. </p>
<p>This class implements an easy-to-use, generalized best-first search. This class has no knowledge of the actual planning task. To use this class, you must provide information about the planning task using three template parameters:</p>
<ul>
<li>PlanningDomain is a simple user-defined class that defines the search heuristic, state transitions, and the meaning of a goal state.</li>
<li>PlanningState is the data type used to represent a state.</li>
<li>PlanningAction is an optional data type used to represent an action. If an action data type is not specified, the compact <a class="el" href="class_default_action.html" title="The default class used to describe a transition between states, if it was not specified by the user...">DefaultAction</a> &lt;PlanningState&gt; class is used.</li>
</ul>
<p>Depending on how you define the action costs and heuristic function, the search can work like A*, near-optimal best-first search, greedy best-first, or any other best-first search technique. An example of using this planner is given below.</p>
<h3>Background </h3>
<p>To compute a plan, the planner needs the following information (i.e., the planning domain):</p>
<ul>
<li>A state space, which is the space of all possible states that can occur in the problem,</li>
<li>An action space, which describes the space of actions that transition from one state to another,</li>
<li>Costs associated with each action,</li>
<li>A heuristic to estimate the "goodness" of a given state, denoted as f, which tells the planner what to search next.</li>
<li>A notion of what it means to be a goal state.</li>
</ul>
<p>The user implicitly provides all this information with the template parameters when instantiating the planner.</p>
<h3>How to use this class </h3>
<p>Using this class is very straightforward:</p>
<ol type="1">
<li>Choose the data types you will use to represent state and action.</li>
<li>Implement a class that describes the state and action spaces, providing functionality that is the same as SteerLib::PlanningDomainBase.</li>
<li>Instantiate the <a class="el" href="class_best_first_search_planner.html" title="A state-space planning algorithm that uses a generalized best-first search.">BestFirstSearchPlanner</a> specifying the template parameters for your planning domain class, the data type for a state, and (optionally) the data type for an action.</li>
<li>Initialize the planner using <a class="el" href="class_best_first_search_planner.html#a00c06f79faf00907ec4906086c37776f" title="Initializes the planner to use the specified instance of the planning domain, and sets the search hor...">init()</a>.</li>
<li>Call <a class="el" href="class_best_first_search_planner.html#a777fb06939a33b3f3effb24b0dbda076" title="Computes a plan as a sequence of states; returns true if the planner could reach the goal...">computePlan()</a>, specifying your start state and goal state.</li>
</ol>
<p><b> Notes: </b></p>
<ul>
<li>The data type you use for a State must implement the assignment "=", equals "==", and comparison "&lt;" operators so that it can be used by this planner. It may be a good idea to test these operators using an STL set and an STL map, because that is what we use for internal data structures.</li>
</ul>
<ul>
<li>It is optional to specify an action data type, otherwise the <a class="el" href="class_default_action.html" title="The default class used to describe a transition between states, if it was not specified by the user...">DefaultAction</a> &lt;PlanningState&gt; data type will be used. This default simply contains the cost of the action, and the resulting new state of the action, which is compact and suitable for most common planning tasks.</li>
</ul>
<ul>
<li>When <a class="el" href="class_best_first_search_planner.html#a777fb06939a33b3f3effb24b0dbda076" title="Computes a plan as a sequence of states; returns true if the planner could reach the goal...">computePlan()</a> is called, the planner will compute either a sequence of states or a sequence of actions, depending on which overloaded function was called.</li>
</ul>
<ul>
<li>Depending on how you implemented the planning domain class, it may be possible to call <a class="el" href="class_best_first_search_planner.html#a777fb06939a33b3f3effb24b0dbda076" title="Computes a plan as a sequence of states; returns true if the planner could reach the goal...">computePlan()</a> any number of times using the same instance of the planner. Furthermore, the planner class maintains no state internally, so it is possible to use separate threads for separate planning tasks using the same instance of the planner (assuming the search horizon stays the same).</li>
</ul>
<ul>
<li>During initialization, a search horizon is specified. This allows the user to limit the number of nodes expanded during the search process (i.e. the number of times that SteerLib::PlanningDomainBase::generateTransitions() will be called). If a complete plan is not found within the allowed number of nodes to expand, <a class="el" href="class_best_first_search_planner.html#a777fb06939a33b3f3effb24b0dbda076" title="Computes a plan as a sequence of states; returns true if the planner could reach the goal...">computePlan()</a> will return false, but will still provide an incomplete plan that it can construct to the node that had the best heuristic f value.</li>
</ul>
<p><b> Recommendations: </b></p>
<ul>
<li>Instead of using larger data structures for State and Action, many times it is appropriate to use an integer ID or a pointer reference for your State data type. This reference/index would then refer to the actual data corresponding to that State/Action. This allows you to maintain a "cache" of states for yourself, which is useful for gathering statistics, debugging your implementation, and for performance of this planner.</li>
</ul>
<ul>
<li>When possible, performance can be improved by inlining the functions you implement in your PlanningDomain class.</li>
</ul>
<h3>Implementing the state and action spaces </h3>
<p>The first template parameter, PlanningDomain, is a class that describes the state space and action space of the planner. This class should be implemented by the user, and it must have at least the same functionality as the SteerLib::PlanningDomainBase class. Refer to the documentation in the SteerLib::PlanningDomainBase class for more information about the three functions that must be implemented.</p>
<p>It is not necessary to inherit the SteerLib::PlanningDomainBase class; it is only required to have the same functionality.</p>
<dl class="section see"><dt>See also:</dt><dd><ul>
<li>Documentation of the SteerLib::PlanningDomainBase class, which describes how states and actions are specified to the planner.</li>
</ul>
</dd></dl>
<h3>Code example </h3>
<div class="fragment"><div class="line">           <span class="keyword">class </span>ExamplePlanningDomain {</div>
<div class="line">             <span class="keyword">public</span>:</div>
<div class="line">               <span class="keywordtype">bool</span> isAGoalState( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; state,</div>
<div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; idealGoalState)</div>
<div class="line">               {</div>
<div class="line">                   <span class="keywordflow">return</span> state == idealGoalState;</div>
<div class="line">               }</div>
<div class="line">          </div>
<div class="line">               <span class="keywordtype">float</span> estimateTotalCost( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; currentState, </div>
<div class="line">                                        <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; idealGoalState,</div>
<div class="line">                                        <span class="keywordtype">float</span> currentg)</div>
<div class="line">               {</div>
<div class="line">                   <span class="comment">// if distance() is admissible, then this implementation is an A* search.</span></div>
<div class="line">                   <span class="keywordtype">float</span> h = distance( currentState, idealGoalState);</div>
<div class="line">                   <span class="keywordtype">float</span> f = currentg + h;  </div>
<div class="line">                   <span class="keywordflow">return</span> f;</div>
<div class="line">               }</div>
<div class="line">          </div>
<div class="line">               <span class="keywordtype">void</span> generateTransitions( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; currentState,</div>
<div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; previousState, </div>
<div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; idealGoalState,</div>
<div class="line">                                         std::vector&lt;SteerLib::DefaultAction&lt;int&gt; &gt; &amp; transitions )</div>
<div class="line">               {</div>
<div class="line">                   <a class="code" href="class_default_action.html" title="The default class used to describe a transition between states, if it was not specified by the user...">DefaultAction&lt;int&gt;</a> newAction;</div>
<div class="line">                   for_each_transition_possible_from_currentState {</div>
<div class="line">                       newAction.cost = cost_of_this_specific_transition;</div>
<div class="line">                       newAction.state = new_state_after_transition;</div>
<div class="line">                       transitions.push_back( newAction );</div>
<div class="line">                   }</div>
<div class="line">               }</div>
<div class="line">          </div>
<div class="line">           };</div>
<div class="line">          </div>
<div class="line">           <span class="keywordtype">int</span> main( )</div>
<div class="line">           {</div>
<div class="line">               <span class="comment">// Of course, in your code these variables would need to be initialized properly.</span></div>
<div class="line">               ExamplePlanningDomain domain;</div>
<div class="line">               <span class="keywordtype">int</span> currentState, goalState;</div>
<div class="line">          </div>
<div class="line">               <span class="comment">// This example has effectively no limited horizon.</span></div>
<div class="line">               <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numNodesInHorizon = UINT_MAX;</div>
<div class="line">          </div>
<div class="line">               <span class="comment">// Instantiate and initialize the planner</span></div>
<div class="line">               <a class="code" href="class_best_first_search_planner.html" title="A state-space planning algorithm that uses a generalized best-first search.">BestFirstSearchPlanner&lt;ExamplePlanningDomain, int&gt;</a> examplePlanner;</div>
<div class="line">               examplePlanner.<a class="code" href="class_best_first_search_planner.html#a00c06f79faf00907ec4906086c37776f" title="Initializes the planner to use the specified instance of the planning domain, and sets the search hor...">init</a>( &amp;domain, numNodesInHorizon);</div>
<div class="line">          </div>
<div class="line">               <span class="comment">// Compute the plan</span></div>
<div class="line">               std::stack&lt;int&gt; outputPlan;</div>
<div class="line">               examplePlanner.<a class="code" href="class_best_first_search_planner.html#a777fb06939a33b3f3effb24b0dbda076" title="Computes a plan as a sequence of states; returns true if the planner could reach the goal...">computePlan</a>(currentState, goalState, outputPlan);</div>
<div class="line">          </div>
<div class="line">               <span class="comment">// Use the plan</span></div>
<div class="line">               <span class="keywordflow">while</span> (!outputPlan.empty()) {</div>
<div class="line">                   <span class="keywordtype">int</span> nextState = outputPlan.pop();</div>
<div class="line">          </div>
<div class="line">                   ... <span class="comment">// other code</span></div>
<div class="line">               }</div>
<div class="line">          </div>
<div class="line">               <span class="keywordflow">return</span> 0;</div>
<div class="line">           }</div>
</div><!-- fragment --> </div><hr/>The documentation for this class was generated from the following file:<ul>
<li>VAST/vast/Assets/Plannar Scripts/Planners In Use/BestFirstSearchPlanner.cs</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 12 2012 00:19:39 for VAST by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
